/*
 * Copyright (c) 2004, 2013-2016 Galois, Inc.
 * Distributed under the terms of the BSD3 license (see LICENSE file)
 */

// Based on the NIST description of SHA1:
//   http://www.itl.nist.gov/fipspubs/fip180-4.htm

//////// Shared logic ////////

f : ([8], [32], [32], [32]) -> [32]
f (t, x, y, z) =
       if (0 <= t)  && (t <= 19) then (x && y) ^ (~x && z)
        | (20 <= t) && (t <= 39) then x ^ y ^ z
        | (40 <= t) && (t <= 59) then (x && y) ^ (x && z) ^ (y && z)
        | (60 <= t) && (t <= 79) then x ^ y ^ z
        else error "f: t out of range"

Hinit : [5][32]
Hinit = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]

Ks : [80][32]
Ks = [ 0x5a827999 | (t : [8]) <- [0..19]  ]
   # [ 0x6ed9eba1 | (t : [8]) <- [20..39] ]
   # [ 0x8f1bbcdc | (t : [8]) <- [40..59] ]
   # [ 0xca62c1d6 | (t : [8]) <- [60..79] ]

block : ([5][32], [16][32]) -> [5][32]
block ([H0, H1, H2, H3, H4], M) =
 [(H0+As@80), (H1+Bs@80), (H2+Cs@80), (H3+Ds@80), (H4+Es@80)]
  where
    Ws : [80][32]
    Ws = M # [ (W3 ^ W8 ^ W14 ^ W16) <<< 1
             | W16 <- drop`{16 - 16} Ws
             | W14 <- drop`{16 - 14} Ws
             | W8  <- drop`{16 - 8}  Ws
             | W3  <- drop`{16 - 3}  Ws
             | (t : [8]) <- [16..79]
             ]
    As = [H0] # TEMP
    Bs = [H1] # As
    Cs = [H2] # [ B <<< 30 | B <- Bs ]
    Ds = [H3] # Cs
    Es = [H4] # Ds
    TEMP : [80][32]
    TEMP = [ (A <<< 5) + f(t, B, C, D) + E + W + K
           | A <- As | B <- Bs | C <- Cs | D <- Ds | E <- Es
           | W <- Ws | K <- Ks
           | (t : [8]) <- [0..79]
           ]

//////// Functional/idiomatic top level ////////

sha1 : {n} (width (8*n) <= 64) => [n][8] -> [160]
sha1 msg = sha1' pmsg
    where
        pmsg = pad(join(msg))

sha1' : {chunks} (fin chunks) => [chunks][512] -> [160]
sha1' pmsg = join (Hs!0)
  where
    Hs = [ Hinit ] #
         [ block(H, split(M))
         | H <- Hs
         | M <- pmsg
         ]

/*
As a summary, a "1" followed by m "0"s followed by a 64-
   bit integer are appended to the end of the message to produce a
   padded message of length 512 * n.  The 64-bit integer is the length
   of the original message.  The padded message is then processed by the
   SHA-1 as n 512-bit blocks.
*/
pad : {msgLen,chunks}
     ( fin msgLen
     , 64 >= width msgLen                             // message width fits in a word
     , chunks     == (msgLen + 65 + 511) / 512
     )
     => [msgLen] -> [chunks][512]
pad msg = split (msg # [True] # (zero:[padding]) # (`msgLen:[64]))
    where type contentLen = msgLen + 65                      // message + header
          type padding    = (512 - contentLen % 512) % 512   // prettier if type #'s could be < 0



//////// Functional tests ////////

t0 = sha1 "" == 0xda39a3ee5e6b4b0d3255bfef95601890afd80709

// Sample messages and their digests from FIPS180-1 appendix.

t1 = sha1 "abc" == 0xA9993E364706816ABA3E25717850C26C9CD0D89D
t2 = sha1 "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq" ==
     0x84983E441C3BD26EBAAE4AA1F95129E5E54670F1
// Running t3 is very slow
/*
t3 = sha1 [ 'a' | (i : [32]) <- [1..1000000] ] ==
     0x34AA973CD4C4DAA4F61EEB2BDBAD27316534016F
*/

property testsPass = [t0, t1, t2 /*, t3 */] == ~zero

//////// Imperative top level ////////

type SHA1State = { h: [5][32]     // Hash of all full blocks seen so far.
                 , block: [64][8] // Current (partial) block
                 , n: [8]         // Number of bytes in current block.
                 , sz: [64]       // Number of bits in message so far.
                 }

sha1_init : SHA1State
sha1_init = { h = Hinit
            , block = zero
            , n = 0
            , sz = 0
            }

sha1_update1 : SHA1State -> [8] -> SHA1State
sha1_update1 s b =
  if s.n == 64
    then { h = block (s.h, split (join s.block))
         , block = [b] # zero
         , n = 1
         , sz = s.sz + 8
         }
    else { h = s.h
         , block = update s.block s.n b
         , n = s.n + 1
         , sz = s.sz + 8
         }

// Want to prove this equivalent to C for n in {0, 1, 2, 63, 64, 65,
// 127, 128, 129}
sha1_update : {n} (fin n) => SHA1State -> [n][8] -> SHA1State
sha1_update s0 bs = ss!0
  where ss = [s0] # [ sha1_update1 s b | s <- ss | b <- bs ]

update : {a, b, c} (fin c) => [b]a -> [c] -> a -> [min b (2 ^^ c)]a
update a i x = [ if j == i then x else e | e <- a | j <- [0 ..] ]

// Add padding and size and process the final block.
sha1_final : SHA1State -> [160]
sha1_final s0 = join (block (h, b'))
  // Because the message is always made up of bytes, and the size is a
  // fixed number of bytes, the 1 pad will always be at least a byte.
  where s1 = sha1_update1 s0 0x80
        // Don't need to add zeros. They're already there. Just update
        // the count of bytes in this block. After adding the 1 pad, there
        // are two possible cases: the size will fit in the current block,
        // or it won't.
        (h, b) = if s1.n <= 56 then (s1.h, s1.block)
                 else (block (s1.h, split (join s1.block)), zero)
        b' = split (join b || (zero # s0.sz))

sha1_imp : {n} (fin n) => [n][8] -> [160]
sha1_imp msg = sha1_final (sha1_update sha1_init msg)

//////// Imperative tests ////////

t0_imp = sha1_imp "" == 0xda39a3ee5e6b4b0d3255bfef95601890afd80709

// Sample messages and their digests from FIPS180-1 appendix.

t1_imp = sha1_imp "abc" == 0xA9993E364706816ABA3E25717850C26C9CD0D89D
t2_imp = sha1_imp "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq" ==
     0x84983E441C3BD26EBAAE4AA1F95129E5E54670F1
// Running t3 is very slow
/*
t3_imp = sha1_imp [ 'a' | (i : [32]) <- [1..1000000] ] ==
     0x34AA973CD4C4DAA4F61EEB2BDBAD27316534016F
*/

property testsPass_imp = [t0_imp, t1_imp, t2_imp /*, t3_imp*/] == ~zero

property imp_correct msg = sha1 msg == sha1_imp msg