/*
 * Copyright (c) 2013-2016 Galois, Inc.
 * Distributed under the terms of the BSD3 license (see LICENSE file)
 */
module HMAC where

import SHA256

//////// Functional version ////////

hmacSHA256 : {pwBytes, msgBytes}
             (fin pwBytes, fin msgBytes
             , 32 >= width msgBytes
             , 64 >= width (8*pwBytes)
             , 64 >= width (8 * (64 + msgBytes))
             ) => [pwBytes][8] -> [msgBytes][8] -> [256]
hmacSHA256 = hmac `{blockLength=64} SHA256 SHA256 SHA256

kinit : { pwBytes, blockLength, digest }
        ( fin pwBytes, fin blockLength, fin digest )
     => ([pwBytes][8] -> [8*digest])
     -> [pwBytes][8]
     -> [blockLength][8]
kinit hash key =
  if `pwBytes > (`blockLength : [max (width pwBytes) (width blockLength)])
  then take `{blockLength} (split (hash key) # (zero : [blockLength][8]))
  else take `{blockLength} (key # (zero : [blockLength][8]))

// Due to limitations of the type system we must accept two
// separate arguments (both aledgedly the same) for two
// separate length inputs.
hmac : { msgBytes, pwBytes, digest, blockLength }
       ( fin pwBytes, fin digest, fin blockLength )
    => ([blockLength + msgBytes][8] -> [8*digest])
    -> ([blockLength + digest][8] -> [8*digest])
    -> ([pwBytes][8] -> [8*digest])
    -> [pwBytes][8]
    -> [msgBytes][8]
    -> [digest*8]
hmac hash hash2 hash3 key message = hash2 (okey # internal)
 where
   ks : [blockLength][8]
   ks = kinit hash3 key
   okey = [k ^ 0x5C | k <- ks]
   ikey = [k ^ 0x36 | k <- ks]
   internal = split (hash (ikey # message))

property pass =
    ~zero ==
    [ hmacSHA256 [0x0b | _ <- [1..20] : [_][6]] "Hi There" == 0xb0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7
    , hmacSHA256 "Jefe" "what do ya want for nothing?" == 0x5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843
    ]

//////// Imperative version ////////
//
// To start, the imperative version is specialized to SHA256.

type SHA512DigestLength = 64

// This mirrors the `s2n_hmac_state` struct.
type HMACState =
     { // alg : HMACAlgorithm // TODO

       hash_block_size         : [16]
     , currently_in_hash_block : [32]
     , block_size              : [16]
     , digest_size             : [8]

     , inner          : SHA256State
     , inner_just_key : SHA256State
     , outer          : SHA256State

     , xor_pad    : [128][8]
     , digest_pad : [SHA512DigestLength][8]
     }

hmac_init : { pwBytes }
            ( fin pwBytes, 64 >= width (8*pwBytes) )
         => [pwBytes][8]
         -> HMACState
hmac_init key =
  { hash_block_size         = hash_block_size
  , currently_in_hash_block = currently_in_hash_block
  , block_size              = block_size
  , digest_size             = digest_size
  , inner                   = inner
  , inner_just_key          = inner_just_key
  , outer                   = outer
  , xor_pad                 = xor_pad
  , digest_pad              = digest_pad
  }
  where
    // SHA256-specific values.
    //
    // /usr/include/openssl/sha.h
    currently_in_hash_block = 0
    sha256_digest_length    = 32
    digest_size             = sha256_digest_length
    block_size              = 64
    hash_block_size         = 64

    k0 : [64][8]
    k0 = kinit SHA256Imp key

    ikey = [ k ^ 0x36 | k <- k0 ]
    okey = [ k ^ 0x6a | k <- ikey ]

    inner_just_key = SHA256Update SHA256Init ikey
    inner          = inner_just_key

    // MAYBE TODO: In `s2n_hmac_init`, these are used in the hash
    // computation for `k0`, when the key is long and needs to be
    // hashed. So, we need to refactor `kinit` if we want the state to
    // match here. However, this potential hash value in `outer` in
    // never used outside of `hmac_init`, so hopefully we can just
    // avoid modeling it.
    outer      = SHA256Init
    digest_pad = zero

    xor_pad = okey # zero

hmac_update : {n} (32 >= width n) => HMACState -> [n][8] -> HMACState
hmac_update s m =
  { inner = SHA256Update s.inner m

  // TODO: as pointed out by Joey, this will overflow when `n` is
  // larger than `2^32 - 1 - 128000`.
  , currently_in_hash_block =
      (s.currently_in_hash_block +
       ((128000 + `n) % (zero # s.hash_block_size))) %
      (zero # s.block_size)

  // Rest unchanged.
  , hash_block_size = s.hash_block_size
  , block_size      = s.block_size
  , digest_size     = s.digest_size
  , inner_just_key  = s.inner_just_key
  , outer           = s.outer
  , xor_pad         = s.xor_pad
  , digest_pad      = s.digest_pad
  }

// TODO: What about `size` argument to `s2n_hmac_digest`? The `size`
// argument is supposed to be the "digest length" of the underlying
// hash. Here we are specializing to SHA256, so `size` would be 32.
hmac_digest : HMACState -> (HMACState, [256])
hmac_digest s = (sout, out)
  where
    // The 32 here is specific to SHA256.
    hin : [32][8]
    hin = split (SHA256Final inner)
    digest_pad : [SHA512DigestLength][8]
    digest_pad = hin # zero

    // The 64 here is specific to SHA256.
    okey : [64][8]
    okey = take s.xor_pad

    // TODO: the `inner` and `outer` here are probably not accurate:
    // in s2n, the `s2n_hash_digest` has been called on them, which
    // presumably can change them (calls `SHA256_Final` from
    // underlying C crypto lib behind the scenes). However, our
    // Cryptol `SHA256Final` does not change the hash state. Even
    // if we leave the hash function uninterpreted later, we will
    // still need to change the interface of our Cryptol `<hash>Final`
    // to additionally return an updated `<hash>State`.
    outer = SHA256Update SHA256Init (okey # hin)
    inner = s.inner

    out = SHA256Final outer

    sout : HMACState
    sout =
      { inner      = inner
      , outer      = outer
      , digest_pad = digest_pad

      // Rest unchanged.
      , hash_block_size         = s.hash_block_size
      , currently_in_hash_block = s.currently_in_hash_block
      , block_size              = s.block_size
      , digest_size             = s.digest_size
      , inner_just_key          = s.inner_just_key
      , xor_pad                 = s.xor_pad
      }

hmac_reset : HMACState -> HMACState
hmac_reset s =
  { currently_in_hash_block = 0
  , inner                   = s.inner_just_key

  // Rest unchanged.
  , hash_block_size = s.hash_block_size
  , block_size      = s.block_size
  , digest_size     = s.digest_size
  , inner_just_key  = s.inner_just_key
  , outer           = s.outer
  , xor_pad         = s.xor_pad
  , digest_pad      = s.digest_pad
  }

hmac_imp : { a, b }
           ( fin b, 64 >= width (8 * a)
           , 32 >= width b
           )
        => [a][8]
        -> [b][8]
        -> [256]
hmac_imp key msg = (hmac_digest (hmac_update (hmac_init key) msg)).1


//////// Equivalence of implementations ////////

hmacSHA256_imp = hmac_imp

imp_correct : { klen, mlen }
              ( 32 >= width mlen, 64 >= width (8 * klen) )
           => [klen][8] -> [mlen][8] -> Bit
property imp_correct key msg = hmacSHA256 key msg == hmacSHA256_imp key msg

//////// Translations between C/LLVM and Cryptol data types ////////

// s2n_hash.h
/*
typedef enum { S2N_HASH_NONE, S2N_HASH_MD5, S2N_HASH_SHA1, S2N_HASH_SHA224, S2N_HASH_SHA256, S2N_HASH_SHA384,
    S2N_HASH_SHA512, S2N_HASH_MD5_SHA1
} s2n_hash_algorithm;
*/
S2N_HASH_SHA256 = 4:[32]

// /usr/include/openssl/sha.h
/*
134 typedef struct SHA256state_st {
135     SHA_LONG h[8];
136     SHA_LONG Nl, Nh;
137     SHA_LONG data[SHA_LBLOCK];
138     unsigned int num, md_len;
139 } SHA256_CTX;
*/
// Looking at the generated LLVM in ':/src/hmac.ll' gives the precise
// laytout, without having to find the definitions of the above
// macros.
/*
%struct.SHA512state_st = type { [8 x i64], i64, i64, %union.anon.0, i32, i32 }
%union.anon.0 = type { [16 x i64] }
*/

// The hash state in s2n is stored in a union, and the largest member
// of that union is the SHA512 hash state. So, we need to translate
// between SHA512 and SHA256 hash states.
//
// /usr/include/openssl/sha.h
/*
183 typedef struct SHA512state_st {
184     SHA_LONG64 h[8];
185     SHA_LONG64 Nl, Nh;
186     union {
187         SHA_LONG64 d[SHA_LBLOCK];
188         unsigned char p[SHA512_CBLOCK];
189     } u;
190     unsigned int num, md_len;
191 } SHA512_CTX;
*/
// :/src/hmac.ll
/*
%struct.SHA256state_st = type { [8 x i32], i32, i32, [16 x i32], i32, i32 }
*/

type SHA512_c_state =
  { h      : [8][64]
  , Nl     : [64]
  , Nh     : [64]
  , u      : [16][64]
  , num    : [32]
  , md_len : [32]
  }
type SHA512_c_bits = 8*64+64+64+16*64+32+32

join512_c_state : SHA512_c_state -> [SHA512_c_bits]
join512_c_state st = join st.h # st.Nl # st.Nh # join st.u # st.num # st.md_len

type SHA256_c_state =
  { h      : [8][32]
  , Nl     : [32]     // The low bits of 'sz'.
  , Nh     : [32]     // The high bits of 'sz'.
  , u      : [16][32] // The 'block': '[16][32] == [8][64]' when flattened.
  , num    : [32]     // The 'n', but extended to 32 bits.
  , md_len : [32]     // The value of 'md_len' is always 32,
  }                   // i.e. 'SHA256_DIGEST_LENGTH'.
type SHA256_c_bits = 8*32+32+32+16*32+32+32

join256_c_state : SHA256_c_state -> [SHA256_c_bits]
join256_c_state st = join st.h # st.Nl # st.Nh # join st.u # st.num # st.md_len

SHA256_DIGEST_LENGTH = 32:[32]

// Recall the 'SHA256State' in our Cryptol model in './SHA256.cry':
/*
type SHA256State = { h     : [8][32]
                   , block : [64][8]
                   , n     : [16]
                   , sz    : [64]
                   }
*/

// TODO(conathan): is my endianness correct here? In other words, I'm
// using the initial, high order bits of the SHA512 state to construct
// the SHA256 state, but it could instead be the lower order bits. I
// should inspect the LLVM or do a simple C experiment to justify my
// choice.
sha512_c_state_to_sha256_c_state : SHA512_c_state -> SHA256_c_state
sha512_c_state_to_sha256_c_state st =
  { h      = split (take bits)
  , Nl     = take (drop`{front=8*32} bits)
  , Nh     = take (drop`{front=8*32+32} bits)
  , u      = split (take (drop`{front=8*32+32+32} bits))
  , num    = take (drop`{front=8*32+32+32+16*32} bits)
  , md_len = drop`{front=8*32+32+32+16*32+32} bits
  }
  where
    bits : [SHA256_c_bits]
    bits = take bits0 // Per TODO above, is this 'take' or 'drop'?
    bits0 : [SHA512_c_bits]
    bits0 = join512_c_state st

// We need the original state, 'st0', to compute the trailing SHA512
// bits which aren't used in the SHA256 state.
sha256_c_state_to_sha512_c_state : SHA512_c_state -> SHA256_c_state -> SHA512_c_state
sha256_c_state_to_sha512_c_state st0 st =
  { h      = split (take bits)
  , Nl     = take (drop`{front=8*64} bits)
  , Nh     = take (drop`{front=8*64+64} bits)
  , u      = split (take (drop`{front=8*64+64+64} bits))
  , num    = take (drop`{front=8*64+64+64+16*64} bits)
  , md_len = drop`{front=8*64+64+64+16*64+32} bits
  }
  where
    bits : [SHA512_c_bits]
    bits = join256_c_state st # drop bits0 // The endianness TODO affects this.
    bits0 : [SHA512_c_bits]
    bits0 = join512_c_state st0

sha256_c_state_to_sha256_state : SHA256_c_state -> SHA256State
sha256_c_state_to_sha256_state st =
  { h     = st.h
  , block = split (join st.u)
  , n     = drop st.num
  , sz    = st.Nh # st.Nl
  }
  where
    bits : [SHA256_c_bits]
    bits = join256_c_state st

sha256_state_to_sha256_c_state : SHA256State -> SHA256_c_state
sha256_state_to_sha256_c_state st =
  { h      = st.h
  , Nl     = Nl
  , Nh     = Nh
  , u      = split (join st.block)
  , num    = (zero # st.n) : [32]
  , md_len = SHA256_DIGEST_LENGTH
  }
  where
    [Nh, Nl] = split st.sz

sha256_init_sha512_c_state : SHA512_c_state -> SHA512_c_state
sha256_init_sha512_c_state st0_c_512 = st1_c_512
  where
   st1_256 = SHA256Init
   st1_c_256 = sha256_state_to_sha256_c_state st1_256
   st1_c_512 = sha256_c_state_to_sha512_c_state st0_c_512 st1_c_256
