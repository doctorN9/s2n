import "HMAC.cry";
m <- llvm_load_module "../src/hmac.bc";

let hmac_state = do {
    llvm_ptr "state" (llvm_struct "struct.s2n_hmac_state");
    alg <- llvm_var "state->0" (llvm_int 32);
    hash_block_size <- llvm_var "state->1" (llvm_int 16);
    currently_in_hash_block <- llvm_var "state->2" (llvm_int 32);
    block_size <- llvm_var "state->3" (llvm_int 16);
    digest_size <- llvm_var "state->4" (llvm_int 8);
    xor_pad <- llvm_var "state->8" (llvm_array 128 (llvm_int 8));
    digest_pad <- llvm_var "state->9" (llvm_array 64 (llvm_int 8));
    llvm_assert_eq "state->0" {{ 4 : [32] }}; // S2N_HMAC_SHA256
    // TODO: return values of llvm_vars.
    return ();
};

// We specialize everything to SHA256 for now. So, we only define the
// SHA256 related constants. See './HMAC.cry' for summary of relevant
// C and LLVM sources, e.g. the struct layouts leading to the
// mysterious paths like "(((state->1).0).3).0" below.

let hash_init_spec = do {
    llvm_ptr "state" (llvm_struct "struct.s2n_hash_state");
    llvm_var "state->0" (llvm_int 32);
    alg0 <- llvm_var "alg" (llvm_int 32);
    // Feature requests:
    //
    // - named fields: being able to define the mapping ourselves is
    //   sufficient. I.e. in the .saw file I would describe the
    //   mapping with something like
    //
    //     [ ("->alg", "->0")
    //     , ("->hash_ctx", "->1")
    //     ]
    //
    // - support for entire structs: having to break a struct down into
    //   all of its fields is tedious and error prone. I would like to
    //   simply do
    //
    //
    //     hash_ctx0 <- llvm_var "(state->1).0" (llvm_struct "struct.SHA512state_st");
    //
    //   and then have 'hash_ctx0' be of type
    //
    //     ([8][64], [64], [64], [16][64], [32], [32])
    //
    //   or perhaps even better, of type 'SHA512_c_state'. Or,
    //   for named fields on the Cryptol tuple type, I could define
    //   projections, or manually map the tuple to a 'SHA512_c_state'.
    hash_ctx0_h      <- llvm_var "((state->1).0).0" (llvm_array 8 (llvm_int 64));
    hash_ctx0_Nl     <- llvm_var "((state->1).0).1" (llvm_int 64);
    hash_ctx0_Nh     <- llvm_var "((state->1).0).2" (llvm_int 64);
    hash_ctx0_u      <- llvm_var "(((state->1).0).3).0" (llvm_array 16 (llvm_int 64));
    hash_ctx0_num    <- llvm_var "((state->1).0).4" (llvm_int 32);
    hash_ctx0_md_len <- llvm_var "((state->1).0).5" (llvm_int 32);

    let st0 = {{
      { h      = hash_ctx0_h
      , Nl     = hash_ctx0_Nl
      , Nh     = hash_ctx0_Nh
      , u      = hash_ctx0_u
      , num    = hash_ctx0_num
      , md_len = hash_ctx0_md_len
      } : SHA512_c_state
    }};
    // We need to pass in the starting state since many of the bits in
    // the union are unused in the SHA256 state.
    let st1 = {{ sha256_init_sha512_c_state st0 }};

    // Specialize to SHA256.
    llvm_assert_eq "alg" {{ S2N_HASH_SHA256 }};

    llvm_ensure_eq "state->0" {{ S2N_HASH_SHA256 }};
    llvm_ensure_eq "((state->1).0).0" {{ st1.h }};
    llvm_ensure_eq "((state->1).0).1" {{ st1.Nl }};
    llvm_ensure_eq "((state->1).0).2" {{ st1.Nh }};
    llvm_ensure_eq "(((state->1).0).3).0" {{ st1.u }};
    llvm_ensure_eq "((state->1).0).4" {{ st1.num }};
    llvm_ensure_eq "((state->1).0).5" {{ st1.md_len }};

    llvm_return {{ 0 : [32] }};
    llvm_no_simulate;
};

// Here, `n` is the size of the new data to hash.
let hash_update_spec n = do {
    llvm_ptr "state" (llvm_struct "struct.s2n_hash_state");
    llvm_ptr "data" (llvm_array n (llvm_int 8)); // TODO: is it a byte array?
    data <- llvm_var "*data" (llvm_array n (llvm_int 8));
    size <- llvm_var "size" (llvm_int 32);
    llvm_return {{ 0 : [32] }};
    llvm_no_simulate;
};

// Here, `n` is the digest size for the specific hash algorithm.
let hash_digest_spec n = do {
    llvm_ptr "state" (llvm_struct "struct.s2n_hash_state");
    llvm_ptr "out" (llvm_array n (llvm_int 8)); // TODO: is it a byte array?
    data <- llvm_var "*out" (llvm_array n (llvm_int 8));
    size <- llvm_var "size" (llvm_int 32);
    llvm_return {{ 0 : [32] }};
    llvm_no_simulate;
};

let hmac_init_spec n = do {
    hmac_state;
    alg <- llvm_var "alg" (llvm_int 32);
    llvm_ptr "key" (llvm_array n (llvm_int 8)); // TODO: is it a byte array?
    key <- llvm_var "*key" (llvm_array n (llvm_int 8));
    klen <- llvm_var "klen" (llvm_int 32);
    llvm_return {{ 0 : [32] }};

    llvm_sat_branches true;
    llvm_no_simulate;
};

let hmac_update_spec n = do {
    hmac_state;
    llvm_ptr "in" (llvm_array n (llvm_int 8)); // TODO: is it a byte array?
    inp <- llvm_var "*in" (llvm_array n (llvm_int 8));
    size <- llvm_var "size" (llvm_int 32);
    llvm_return {{ 0 : [32] }};

    llvm_no_simulate;
};

let hmac_digest_spec n = do {
    hmac_state;
    llvm_ptr "out" (llvm_array n (llvm_int 8)); // TODO: is it a byte array?
    out <- llvm_var "*out" (llvm_array n (llvm_int 8));
    size <- llvm_var "size" (llvm_int 32);
    llvm_return {{ 0 : [32] }};

    llvm_sat_branches true;
    llvm_no_simulate;
};

hash_init_ov   <- llvm_verify m "s2n_hash_init"   [] hash_init_spec;
hash_update_ov <- llvm_verify m "s2n_hash_update" [] (hash_update_spec 10);
hash_digest_ov <- llvm_verify m "s2n_hash_digest" [] (hash_digest_spec 20);

hmac_init_ov   <- llvm_verify m "s2n_hmac_init"
                  [hash_init_ov, hash_update_ov, hash_digest_ov]
                  (hmac_init_spec 10);
hmac_update_ov <- llvm_verify m "s2n_hmac_update"
                  [hash_update_ov]
                  (hmac_update_spec 10);
hmac_digest_ov <- llvm_verify m "s2n_hmac_digest"
                  [hash_init_ov, hash_update_ov, hash_digest_ov]
                  (hmac_digest_spec 20);

print "Done.";
