// This module provides an specification of the
// TLS 1.2 handshake message state machine according to RFCs 5246, 5077 and 6066 // (OCSP extension only). This
// is an overapproximation because state transitions don't depend on
// message contents --- and, in reality, they should.

module TLSHandshake where

import Cryptol::Extras
import s2n_advance_message

// Main correctness property: a simulation of the S2N handshake state
// machine by an RFC-derived state machine

// \forall conn \in Connection. valid (conn) ==> \exists r1, r2 \in State.
// s2nRFCState (ACTIVE_STATE conn) r1 /\
// s2nRFCState (ACTIVE_STATE (s2n_advance_message conn) r2)  /\
// handshakeTransition r1 r2
rfcSimulatesS2N : connection -> Parameters -> Bool
rfcSimulatesS2N conn pars = 
   valid_connection conn ==>
   or [rfcSimulatesS2N2 conn pars s1 s2 | s1 <- states, s2 <- states]
   where states = [0 .. 23] // warning, 23 is a hardcoding of the maximum state number in the RFC state machine

rfcSimulatesS2N2 : connection -> Parameters -> State -> State -> Bool
rfcSimulatesS2N2 conn pars rfcPre rfcPost =
   (s2nRFCState s2nPre rfcPre /\
    s2nRFCState s2nPost rfcPost /\
    handshakeTransition pars rfcPre rfcPost) 
   where s2nPre  = ACTIVE_STATE conn
         s2nPost = ACTIVE_STATE (advance_message conn)

type State = [5]

// states
(helloRequestSent : State) = 0
(clientHelloSent : State) = 1
(serverHelloSent : State) = 2
(serverCertificateSent : State) = 3
(serverKeyExchangeSent : State) = 4
(certificateRequestSent : State) = 5
(serverHelloDoneSent : State) = 6
(serverHelloDoneSentCertRequested : State) = 7
(clientCertificateSent : State) = 8
(clientKeyExchangeSent : State) = 9
(clientKeyExchangeSentCertSent : State) = 10
(certificateVerifySent : State) = 11
(clientChangeCipherSpecSent : State) = 12
(clientFinishedSent : State) = 13
(serverChangeCipherSpecSent : State) = 14
(serverFinishedSent : State) = 15
(applicationDataTransmission : State) = 16
(serverNewSessionTicketSent : State) = 17
(serverRenewSessionTicketSent : State) = 18
(serverChangeCipherSpecWithTicketSent : State) = 19
(serverFinishedWithTicketSent : State) = 20
(clientChangeCipherSpecWithTicketSent : State) = 21
(clientFinishedWithTicketSent : State) = 22
(serverCertificateStatusSent : State) = 23

// TLS protocol types
type Protocol = [2]
(handshake : Protocol) = 0
(changeCipherSpec : Protocol) = 1
(alert : Protocol) = 2
(data : Protocol) = 3

//message types
type MessageType = [4]
//handshake message types
(helloRequest       : MessageType) = 0
(clientHello        : MessageType) = 1
(serverHello        : MessageType) = 2
(certificate        : MessageType) = 3
(serverKeyExchange  : MessageType) = 4
(certificateRequest : MessageType) = 5
(serverHelloDone    : MessageType) = 6
(certificateVerify  : MessageType) = 7
(clientKeyExchange  : MessageType) = 8
(finished           : MessageType) = 9
(newSessionTicket   : MessageType) = 10
(certificateStatus  : MessageType) = 11

// ChangeCipherSpec message types
(changeCipherSpecMessage : MessageType) = 0

// Data message types
(applicationData : MessageType) = 0
(error : MessageType) = 1

// sender
type Sender = [2]
(server   : Sender) = 0
(client   : Sender) = 1
(both     : Sender) = 2
(noSender : Sender) = 3

// Key exchange algorithms
type KeyExchange = [3]
(DH_anon : KeyExchange) = 0
(DHE_DSS : KeyExchange) = 1
(DHE_RSA : KeyExchange) = 2
(RSA     : KeyExchange) = 3
(DH_DSS  : KeyExchange) = 4
(DH_RSA  : KeyExchange) = 5

// Protocol parameters that determine the transition to take in each state
type Parameters = {keyExchange : KeyExchange //Negotiated key exchange algorithm
                  ,sessionTicket : Bit
                  ,renewSessionTicket : Bit //Whether the server decides to renew a session ticket
                  ,sendCertificateStatus : Bit //Whether the server decides to send the certificate status message
                  ,requestClientCert : Bit //Whether the server requests a certificate from the client
                  ,includeSessionTicket : Bit //Whether the server includes a session ticket extension in SERVER_HELLO
                  }

// Handshake state transition relation per the RFCs
handshakeTransition : Parameters -> State -> State -> Bool
handshakeTransition params old new =
  or [ old == from /\ new == to /\ p | (from, p, to) <- valid_transitions]
  where noKE = params.keyExchange == RSA \/ params.keyExchange == DH_DSS \/ params.keyExchange == DH_RSA // key exchange algorithm does not require KeyExchange messages
        valid_transitions =
          [(helloRequestSent, True, clientHelloSent)
          
          ,(clientHelloSent,  True, serverHelloSent)
          
          ,(serverHelloSent, params.keyExchange != DH_anon /\ ~params.sessionTicket, serverCertificateSent)
          ,(serverHelloSent, params.keyExchange == DH_anon /\ ~params.sessionTicket, serverKeyExchangeSent)
          ,(serverHelloSent, params.sessionTicket /\ params.renewSessionTicket,  serverNewSessionTicketSent)
          ,(serverHelloSent, params.sessionTicket /\ ~params.renewSessionTicket, serverChangeCipherSpecWithTicketSent)

          ,(serverCertificateSent, noKE /\ ~params.requestClientCert /\ ~params.sendCertificateStatus, serverHelloDoneSent)
          ,(serverCertificateSent, noKE /\ params.requestClientCert /\ ~params.sendCertificateStatus, certificateRequestSent)
          ,(serverCertificateSent, ~noKE /\ ~params.sendCertificateStatus, serverKeyExchangeSent)
          ,(serverCertificateSent, params.sendCertificateStatus,  serverCertificateStatusSent)

          ,(serverKeyExchangeSent, ~params.requestClientCert, serverHelloDoneSent)
          ,(serverKeyExchangeSent, params.requestClientCert, certificateRequestSent)

          ,(certificateRequestSent, True, serverHelloDoneSentCertRequested)

          ,(serverHelloDoneSent, True, clientKeyExchangeSent)

          ,(clientKeyExchangeSent, True, clientChangeCipherSpecSent)

          ,(serverHelloDoneSentCertRequested, True, clientCertificateSent)

          ,(clientCertificateSent, True, clientKeyExchangeSentCertSent)

          ,(clientKeyExchangeSentCertSent, True, certificateVerifySent)

          ,(certificateVerifySent, True, clientChangeCipherSpecSent)

          ,(clientChangeCipherSpecSent, True, clientFinishedSent)

          ,(clientFinishedSent, ~params.includeSessionTicket, serverChangeCipherSpecSent)
          ,(clientFinishedSent, params.includeSessionTicket, serverNewSessionTicketSent)
          
          ,(serverNewSessionTicketSent, True, serverChangeCipherSpecSent)
          
          ,(serverChangeCipherSpecSent, True, serverFinishedSent)
          
          ,(serverFinishedSent, True, applicationDataTransmission)
          
          ,(serverNewSessionTicketSent, True, serverChangeCipherSpecWithTicketSent)
          
          ,(serverChangeCipherSpecWithTicketSent, True, serverFinishedWithTicketSent)
          
          ,(serverFinishedWithTicketSent, True, clientChangeCipherSpecWithTicketSent)
          
          ,(clientChangeCipherSpecWithTicketSent, True, clientFinishedWithTicketSent)
          
          ,(clientFinishedWithTicketSent, True, applicationDataTransmission)

          ,(serverCertificateStatusSent, noKE /\ ~params.requestClientCert, serverHelloDoneSent)
          ,(serverCertificateStatusSent, noKE /\ params.requestClientCert, certificateRequestSent)
          ,(serverCertificateStatusSent, ~noKE, serverKeyExchangeSent)
          ]

fst (a, b) = a
snd (a, b) = b

type Message = {messageType : MessageType
               ,protocol : Protocol
               ,sender : Sender
               }

mkMessage : Sender -> Protocol -> MessageType -> Message
mkMessage s p mt = {sender = s, protocol = p, messageType = mt}

// Message sent in each state
message : State -> Message
message = lookupDefault messages (mkMessage noSender data error)
    where messages =
            [(helloRequestSent, mkMessage server handshake helloRequest)
            ,(clientHelloSent, mkMessage client handshake clientHello)
            ,(serverHelloSent, mkMessage server handshake serverHello)
            ,(serverCertificateSent, mkMessage server handshake certificate)
            ,(serverKeyExchangeSent, mkMessage server handshake serverKeyExchange)
            ,(certificateRequestSent, mkMessage server handshake certificateRequest)
            ,(serverHelloDoneSent, mkMessage server handshake serverHelloDone)
            ,(serverHelloDoneSentCertRequested, mkMessage server handshake serverHelloDone)
            ,(clientCertificateSent, mkMessage client handshake certificate)
            ,(clientKeyExchangeSent, mkMessage client handshake clientKeyExchange)
            ,(clientKeyExchangeSentCertSent, mkMessage client handshake clientKeyExchange)
            ,(certificateVerifySent, mkMessage client handshake certificateVerify)
            ,(clientChangeCipherSpecSent, mkMessage client changeCipherSpec changeCipherSpecMessage)
            ,(clientFinishedSent, mkMessage client handshake finished)
            ,(serverChangeCipherSpecSent, mkMessage server changeCipherSpec changeCipherSpecMessage)
            ,(serverFinishedSent, mkMessage server handshake finished)
            ,(applicationDataTransmission, mkMessage both data applicationData)
            ,(serverNewSessionTicketSent, mkMessage server handshake newSessionTicket)
            ,(serverChangeCipherSpecWithTicketSent, mkMessage server changeCipherSpec changeCipherSpecMessage)
            ,(serverFinishedWithTicketSent, mkMessage server handshake finished)
            ,(clientChangeCipherSpecWithTicketSent, mkMessage client changeCipherSpec changeCipherSpecMessage)
            ,(clientFinishedWithTicketSent, mkMessage client handshake finished)
            ,(serverCertificateStatusSent, mkMessage server handshake certificateStatus)
            ]

lookupDefault : {a, b, n} (fin n, Cmp a) => [n](a, b) -> b -> a -> b
lookupDefault dict def key = fst (foldl find (def, False) dict)
   where find (value, found) (key', value') =
           if found then (value, found)
           else if key == key' then (value', True)
                else (value, found)

// relation between RFC and s2n handshake state machines
s2nRFCState : handshake_action -> State -> Bool
s2nRFCState hsa rfcstate =
   //same senders
   (sender2writer (message rfcstate).sender == hsa.writer) /\
   //same record type/protocol
   (protocol2recordType (message rfcstate).protocol == hsa.record_type) /\
   //same message type
   (s2nMessageType rfcstate == hsa.message_type)

// convert a specification representation of sender to a 'writer' character in s2n.
sender2writer : Sender -> [8]
sender2writer sndr = if sndr == server then 'S'
                else if sndr == client then 'C'
                else if sndr == both   then 'B'
                else                        'E'

// convert protocol number to s2n TLS record type constant
protocol2recordType : Protocol -> [8]
protocol2recordType = lookupDefault protocols TLS_APPLICATION_DATA
   where protocols = [(handshake, TLS_HANDSHAKE)
                     ,(changeCipherSpec, TLS_CHANGE_CIPHER_SPEC)
                     ,(alert, TLS_ALERT)
                     ,(data, TLS_APPLICATION_DATA)
                     ]

s2nMessageType : State -> [8]
s2nMessageType state =
  if prot == handshake then (if mt == helloRequest then TLS_HELLO_REQUEST
                       else if mt == clientHello  then TLS_CLIENT_HELLO
                       else if mt == serverHello  then TLS_SERVER_HELLO
                       else if mt == certificate  then (if send == server then TLS_SERVER_CERT
                                                         else if send == client then TLS_CLIENT_CERT
                                                         else ERROR_MESSAGE)
                       else if mt == serverKeyExchange then TLS_SERVER_KEY
                       else if mt == certificateRequest then TLS_SERVER_CERT_REQ
                       else if mt == serverHelloDone then TLS_SERVER_HELLO_DONE
                       else if mt == certificateVerify then TLS_CLIENT_CERT_VERIFY
                       else if mt == clientKeyExchange then TLS_CLIENT_KEY
                       else if mt == finished then (if send == server then TLS_SERVER_FINISHED
                                                     else if send == client then TLS_SERVER_FINISHED
                                                     else ERROR_MESSAGE)
                       else if mt == newSessionTicket then TLS_SERVER_NEW_SESSION_TICKET
                       else if mt == certificateStatus then TLS_SERVER_CERT_STATUS
                       else ERROR_MESSAGE)

  else 0
     where mt = (message state).messageType
           send = (message state).sender
           prot = (message state).protocol

ERROR_MESSAGE = 10 // unused in current s2n