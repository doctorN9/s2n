// This module provides an specification of the
// TLS 1.2 handshake message state machine according to RFCs 5246, 5077 and 6066 // (OCSP extension only). This
// is an overapproximation because state transitions don't depend on
// message contents --- and, in reality, they should.

module TLSHandshake where

import Cryptol::Extras
import s2n_advance_message

// Main correctness property: a simulation of the S2N handshake state
// machine by an RFC-derived state machine

// \forall conn \in Connection. valid (conn).
// \forall pars \in Parameters. conn `connectionParameters` pars. ==>
// \exists r1, r2 \in State.
// s2nRFCState (ACTIVE_STATE conn) r1 /\
// s2nRFCState (ACTIVE_STATE (s2n_advance_message conn) r2)  /\
// handshakeTransition r1 r2
rfcSimulatesS2N : {len} (fin len) => connection -> Parameters -> Bool
rfcSimulatesS2N conn pars = 
   initial_connection conn /\ connectionParameters conn pars ==>
   and (map (uncurry s2nRFCState) (zip (traceS2N `{n = len} conn) (traceRFC pars))) 

// rfcSimulatesS2N2 : connection -> Parameters -> State -> State -> Bool
// rfcSimulatesS2N2 conn pars rfcPre rfcPost =
//    (s2nRFCState s2nPre rfcPre /\
//     s2nRFCState s2nPost rfcPost /\
//     handshakeTransition pars rfcPre rfcPost) 
//    where s2nPre  = ACTIVE_STATE conn
//          conn'   = if helloState then conn_set_handshake_type conn else conn
//          s2nPost = ACTIVE_STATE (advance_message conn')
//          

// generate a sequence of states for the the RFC handshake state machine given
// handshake parameters
traceRFC : {n} (fin n) => Parameters -> [n]State
traceRFC params = take (iterate (handshakeTransition params) helloRequestSent)

type State = [5]

// states
(helloRequestSent : State) = 0
(clientHelloSent : State) = 1
(serverHelloSent : State) = 2
(serverCertificateSent : State) = 3
(serverKeyExchangeSent : State) = 4
(certificateRequestSent : State) = 5
(serverHelloDoneSent : State) = 6
(serverHelloDoneSentCertRequested : State) = 7
(clientCertificateSent : State) = 8
(clientKeyExchangeSent : State) = 9
(clientKeyExchangeSentCertSent : State) = 10
(certificateVerifySent : State) = 11
(clientChangeCipherSpecSent : State) = 12
(clientFinishedSent : State) = 13
(serverChangeCipherSpecSent : State) = 14
(serverFinishedSent : State) = 15
(applicationDataTransmission : State) = 16
(serverNewSessionTicketSent : State) = 17
(serverRenewSessionTicketSent : State) = 18
(serverChangeCipherSpecWithTicketSent : State) = 19
(serverFinishedWithTicketSent : State) = 20
(clientChangeCipherSpecWithTicketSent : State) = 21
(clientFinishedWithTicketSent : State) = 22
(serverCertificateStatusSent : State) = 23

// TLS protocol types
type Protocol = [2]
(handshake : Protocol) = 0
(changeCipherSpec : Protocol) = 1
(alert : Protocol) = 2
(data : Protocol) = 3

//message types
type MessageType = [4]
//handshake message types
(helloRequest       : MessageType) = 0
(clientHello        : MessageType) = 1
(serverHello        : MessageType) = 2
(certificate        : MessageType) = 3
(serverKeyExchange  : MessageType) = 4
(certificateRequest : MessageType) = 5
(serverHelloDone    : MessageType) = 6
(certificateVerify  : MessageType) = 7
(clientKeyExchange  : MessageType) = 8
(finished           : MessageType) = 9
(newSessionTicket   : MessageType) = 10
(certificateStatus  : MessageType) = 11

// ChangeCipherSpec message types
(changeCipherSpecMessage : MessageType) = 0

// Data message types
(applicationData : MessageType) = 0
(error : MessageType) = 1

// sender
type Sender = [2]
(server   : Sender) = 0
(client   : Sender) = 1
(both     : Sender) = 2
(noSender : Sender) = 3

// Key exchange algorithms
type KeyExchange = [3]
(DH_anon : KeyExchange) = 0
(DHE_DSS : KeyExchange) = 1
(DHE_RSA : KeyExchange) = 2
(RSA     : KeyExchange) = 3
(DH_DSS  : KeyExchange) = 4
(DH_RSA  : KeyExchange) = 5

// Protocol parameters that determine the transition to take in each state
type Parameters = {keyExchange : KeyExchange //Negotiated key exchange algorithm
                  ,sessionTicket : Bit // the client had a session ticket
                  ,renewSessionTicket : Bit //Whether the server decides to renew a session ticket
                  ,sendCertificateStatus : Bit //Whether the server decides to send the certificate status message
                  ,requestClientCert : Bit //Whether the server requests a certificate from the client
                  ,includeSessionTicket : Bit //Whether the server includes a session ticket extension in SERVER_HELLO
                  }

// A relation between the s2n_connection struct and the parameters
connectionParameters : connection -> Parameters -> Bit
connectionParameters conn params =
    conn.server_can_send_ocsp == params.sendCertificateStatus
 /\ ((conn.key_exchange_eph /\ keyExchangeEphemeral params) \/
     (~conn.key_exchange_eph /\ keyExchangeNonEphemeral params))
 /\ (conn.is_caching_enabled /\ conn.resume_from_cache) == params.sessionTicket
 /\ (~params.includeSessionTicket) // s2n server does not issue tickets at this time
 /\ (~params.renewSessionTicket) // s2n server does not issue tickets at this time

keyExchangeNonEphemeral : Parameters -> Bit
keyExchangeNonEphemeral params = params.keyExchange == RSA \/ params.keyExchange == DH_DSS \/ params.keyExchange == DH_RSA // key exchange algorithm does not require KeyExchange messages

keyExchangeEphemeral : Parameters -> Bit
keyExchangeEphemeral params =  params.keyExchange == DHE_DSS \/ params.keyExchange == DHE_RSA

// returns the first element of an array that satisfies a given
// predicate. If none found, a provided default value is returned.
find : {n, x} (fin n) => (x -> Bool) -> x -> [n]x -> x
find p def xs = snd (foldl f (False, def) xs)
   where f (found, y) next = if ~found /\ p next then (True, next) else (found, y)

head : {n, x} [n+1]x -> x
head (([a] : [1]x) # _) = a

// Handshake state transition relation per the RFCs
handshakeTransition : Parameters -> State -> State
handshakeTransition params old =
  snd (find fst (True, old) [ (old == from /\ p, to) | (from, p, to) <- valid_transitions])
  where  
        valid_transitions =
          [(helloRequestSent, True, clientHelloSent)
          
          ,(clientHelloSent,  True, serverHelloSent)
          
          ,(serverHelloSent, params.keyExchange != DH_anon /\ ~params.sessionTicket, serverCertificateSent)
          ,(serverHelloSent, params.keyExchange == DH_anon /\ ~params.sessionTicket, serverKeyExchangeSent)
          ,(serverHelloSent, params.sessionTicket /\ params.renewSessionTicket,  serverNewSessionTicketSent)
          ,(serverHelloSent, params.sessionTicket /\ ~params.renewSessionTicket, serverChangeCipherSpecWithTicketSent)

          ,(serverCertificateSent, keyExchangeNonEphemeral params /\ ~params.requestClientCert /\ ~params.sendCertificateStatus, serverHelloDoneSent)
          ,(serverCertificateSent, keyExchangeNonEphemeral params /\ params.requestClientCert /\ ~params.sendCertificateStatus, certificateRequestSent)
          ,(serverCertificateSent, ~(keyExchangeNonEphemeral params) /\ ~params.sendCertificateStatus, serverKeyExchangeSent)
          ,(serverCertificateSent, params.sendCertificateStatus,  serverCertificateStatusSent)

          ,(serverKeyExchangeSent, ~params.requestClientCert, serverHelloDoneSent)
          ,(serverKeyExchangeSent, params.requestClientCert, certificateRequestSent)

          ,(certificateRequestSent, True, serverHelloDoneSentCertRequested)

          ,(serverHelloDoneSent, True, clientKeyExchangeSent)

          ,(clientKeyExchangeSent, True, clientChangeCipherSpecSent)

          ,(serverHelloDoneSentCertRequested, True, clientCertificateSent)

          ,(clientCertificateSent, True, clientKeyExchangeSentCertSent)

          ,(clientKeyExchangeSentCertSent, True, certificateVerifySent)

          ,(certificateVerifySent, True, clientChangeCipherSpecSent)

          ,(clientChangeCipherSpecSent, True, clientFinishedSent)

          ,(clientFinishedSent, ~params.includeSessionTicket, serverChangeCipherSpecSent)
          ,(clientFinishedSent, params.includeSessionTicket, serverNewSessionTicketSent)
          
          ,(serverNewSessionTicketSent, True, serverChangeCipherSpecSent)
          
          ,(serverChangeCipherSpecSent, True, serverFinishedSent)
          
          ,(serverFinishedSent, True, applicationDataTransmission)
          
          ,(serverNewSessionTicketSent, True, serverChangeCipherSpecWithTicketSent)
          
          ,(serverChangeCipherSpecWithTicketSent, True, serverFinishedWithTicketSent)
          
          ,(serverFinishedWithTicketSent, True, clientChangeCipherSpecWithTicketSent)
          
          ,(clientChangeCipherSpecWithTicketSent, True, clientFinishedWithTicketSent)
          
          ,(clientFinishedWithTicketSent, True, applicationDataTransmission)

          ,(serverCertificateStatusSent, keyExchangeNonEphemeral params /\ ~params.requestClientCert, serverHelloDoneSent)
          ,(serverCertificateStatusSent, keyExchangeNonEphemeral params /\ params.requestClientCert, certificateRequestSent)
          ,(serverCertificateStatusSent, ~(keyExchangeNonEphemeral params), serverKeyExchangeSent)
          ]

fst (a, b) = a
snd (a, b) = b

type Message = {messageType : MessageType
               ,protocol : Protocol
               ,sender : Sender
               }

mkMessage : Sender -> Protocol -> MessageType -> Message
mkMessage s p mt = {sender = s, protocol = p, messageType = mt}

// Message sent in each state
message : State -> Message
message = lookupDefault messages (mkMessage noSender data error)
    where messages =
            [(helloRequestSent, mkMessage server handshake helloRequest)
            ,(clientHelloSent, mkMessage client handshake clientHello)
            ,(serverHelloSent, mkMessage server handshake serverHello)
            ,(serverCertificateSent, mkMessage server handshake certificate)
            ,(serverKeyExchangeSent, mkMessage server handshake serverKeyExchange)
            ,(certificateRequestSent, mkMessage server handshake certificateRequest)
            ,(serverHelloDoneSent, mkMessage server handshake serverHelloDone)
            ,(serverHelloDoneSentCertRequested, mkMessage server handshake serverHelloDone)
            ,(clientCertificateSent, mkMessage client handshake certificate)
            ,(clientKeyExchangeSent, mkMessage client handshake clientKeyExchange)
            ,(clientKeyExchangeSentCertSent, mkMessage client handshake clientKeyExchange)
            ,(certificateVerifySent, mkMessage client handshake certificateVerify)
            ,(clientChangeCipherSpecSent, mkMessage client changeCipherSpec changeCipherSpecMessage)
            ,(clientFinishedSent, mkMessage client handshake finished)
            ,(serverChangeCipherSpecSent, mkMessage server changeCipherSpec changeCipherSpecMessage)
            ,(serverFinishedSent, mkMessage server handshake finished)
            ,(applicationDataTransmission, mkMessage both data applicationData)
            ,(serverNewSessionTicketSent, mkMessage server handshake newSessionTicket)
            ,(serverChangeCipherSpecWithTicketSent, mkMessage server changeCipherSpec changeCipherSpecMessage)
            ,(serverFinishedWithTicketSent, mkMessage server handshake finished)
            ,(clientChangeCipherSpecWithTicketSent, mkMessage client changeCipherSpec changeCipherSpecMessage)
            ,(clientFinishedWithTicketSent, mkMessage client handshake finished)
            ,(serverCertificateStatusSent, mkMessage server handshake certificateStatus)
            ]

lookupDefault : {a, b, n} (fin n, Cmp a) => [n](a, b) -> b -> a -> b
lookupDefault dict def key = fst (foldl f (def, False) dict)
   where f (value, found) (key', value') =
           if found then (value, found)
           else if key == key' then (value', True)
                else (value, found)

// relation between RFC and s2n handshake state machines
s2nRFCState : handshake_action -> State -> Bool
s2nRFCState hsa rfcstate =
   //same senders
   (sender2writer (message rfcstate).sender == hsa.writer) /\
   //same record type/protocol
   (protocol2recordType (message rfcstate).protocol == hsa.record_type) /\
   //same message type
   (s2nMessageType rfcstate == hsa.message_type)

// convert a specification representation of sender to a 'writer' character in s2n.
sender2writer : Sender -> [8]
sender2writer sndr = if sndr == server then 'S'
                else if sndr == client then 'C'
                else if sndr == both   then 'B'
                else                        'E'

// convert protocol number to s2n TLS record type constant
protocol2recordType : Protocol -> [8]
protocol2recordType = lookupDefault protocols TLS_APPLICATION_DATA
   where protocols = [(handshake, TLS_HANDSHAKE)
                     ,(changeCipherSpec, TLS_CHANGE_CIPHER_SPEC)
                     ,(alert, TLS_ALERT)
                     ,(data, TLS_APPLICATION_DATA)
                     ]

s2nMessageType : State -> [8]
s2nMessageType state =
  if prot == handshake then (if mt == helloRequest then TLS_HELLO_REQUEST
                       else if mt == clientHello  then TLS_CLIENT_HELLO
                       else if mt == serverHello  then TLS_SERVER_HELLO
                       else if mt == certificate  then (if send == server then TLS_SERVER_CERT
                                                         else if send == client then TLS_CLIENT_CERT
                                                         else ERROR_MESSAGE)
                       else if mt == serverKeyExchange then TLS_SERVER_KEY
                       else if mt == certificateRequest then TLS_SERVER_CERT_REQ
                       else if mt == serverHelloDone then TLS_SERVER_HELLO_DONE
                       else if mt == certificateVerify then TLS_CLIENT_CERT_VERIFY
                       else if mt == clientKeyExchange then TLS_CLIENT_KEY
                       else if mt == finished then (if send == server then TLS_SERVER_FINISHED
                                                     else if send == client then TLS_SERVER_FINISHED
                                                     else ERROR_MESSAGE)
                       else if mt == newSessionTicket then TLS_SERVER_NEW_SESSION_TICKET
                       else if mt == certificateStatus then TLS_SERVER_CERT_STATUS
                       else ERROR_MESSAGE)

  else 0
     where mt = (message state).messageType
           send = (message state).sender
           prot = (message state).protocol

ERROR_MESSAGE = 10 // unused in current s2n

// ad-hoc tests
// regression 3
conn1 = {corked = 0,
        corked_io = 0,
        handshake = {handshake_type = 0,
                     message_number = 0},
        is_caching_enabled = False,
        key_exchange_eph = False,
        mode = 0,
        resume_from_cache = False,
        server_can_send_ocsp = False}

pars1 = {includeSessionTicket = False,
        keyExchange = 4,
        renewSessionTicket = False,
        requestClientCert = False,
        sendCertificateStatus = False,
        sessionTicket = False}
