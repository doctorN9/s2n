module CorkUncork where

import Cryptol::Extras
import s2n_advance_message

type State = ([2], [2])
(clientSender : [2]) = 0
(serverSender : [2]) = 1
(appData      : [2]) = 2

(corked : [2]) = 1
(uncorked : [2]) = 0

//TODO: here we really need partial functions and check that only the
//part we implement is actually used.
writer2sender : [8] -> [2]
writer2sender w = if w == 'C' then clientSender else
                  if w == 'S' then serverSender else
                                   appData

corkAdapt : [32] -> [2]
corkAdapt c = if c == 0 then 0 else 1

corkedFromConn : connection -> [32]
corkedFromConn conn = zero # [mode_writer conn.mode == (ACTIVE_STATE conn).writer]

//if low level can make a step, then the high level can. If the low
//level cannot make a step, then the high level can't also
highLevelSimulatesLowLevel : connection -> Bit
highLevelSimulatesLowLevel conn_old =
   if (valid_handshake conn_old.handshake /\ conn_old.mode == S2N_SERVER /\ conn_old.corked_io == 1 /\ (conn_old.corked == corkedFromConn conn_old)) then state_new == (advanceMessage state_old writer_new)
   else True
   where conn_new   = s2n_advance_message conn_old
         writer_old = (ACTIVE_STATE conn_old).writer
         writer_new = (ACTIVE_STATE conn_new).writer
         state_old  = (writer2sender writer_old, corkAdapt conn_old.corked)
         state_new  = (writer2sender writer_new, corkAdapt conn_new.corked)
         input      = writer_new

//We're specifying the server state machine
advanceMessage : State -> [8] -> State
advanceMessage (s, corking) c =
  if (s == clientSender) then
     if c == 'C' then (clientSender, corking)
     else if c == 'S' then (serverSender, corking + 1)
          else (appData, corking)
  else if s == serverSender then
     if c == 'C' then (clientSender, corking - 1)
     else if c == 'S' then (serverSender, corking)
          else (appData, corking - 1)
  else (appData, corking)

//Another one, easier for F*
advanceMessageNoarith : State -> [8] -> State
advanceMessageNoarith (s, corking) c =
  if (s == clientSender) then
     if c == 'C' then (clientSender, corking)
     else if c == 'S' then (serverSender, corked)
          else (appData, corking)
  else if s == serverSender then
     if c == 'C' then (clientSender, uncorked)
     else if c == 'S' then (serverSender, corking)
          else (appData, uncorked)
  else (appData, corking)

prop : State -> [8] -> Bit
prop (s, corking) c =
  if (corking == corked) || (corking == uncorked) then (corking' == corked) || (corking' == uncorked)
  else True
     where (s', corking') = advanceMessage (s, corking) c

prop2 : State -> [8] -> Bit
prop2 (s, corking) c = (s == serverSender /\ corking == uncorked) \/ prop (s, corking) c

run : {n} [n][8] -> [n+1]State
run writers = scanl advanceMessage (clientSender, uncorked) writers

exec2 : {n} (fin n) => [n][8] -> State
exec2 writers = resultState ! 0
    where resultState = [(clientSender, uncorked)] # [advanceMessage s c | c <- writers | s <- resultState ]
    
exec : {n} (fin n) => [n][8] -> State
exec writers = foldl advanceMessage (clientSender, uncorked) writers

prop3 : [12][8] -> Bit
prop3 writers = corking == corked \/ corking == uncorked
  where (s, corking) = exec writers

// resultState ! 0
//     where resultState  = [(clientSender, uncorked)] # [advanceMessage s c | c <- writers | s <- resultState ]